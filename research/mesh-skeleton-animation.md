# Mesh skeletons & animation flow across reference projects

Most real-time mesh pipelines maintain an explicit skeleton hierarchy (a tree of bones), per-vertex bone indices + weights, and animation clips keyed per-bone index. Keyframes reference bone indices directly, so once the skeleton is known the runtime just blends transforms and applies them to the skinning shader. The Gamebryo/NetImmerse ecosystem layers another abstraction on top of this: the skin lives in `NiSkinInstance`/`NiSkinData`, the skeleton is expressed through named `NiNode`s, and animation is driven by controllers (`NiTimeController`, interpolators, and `.kf` sequences) that point back to those nodes by name. Each reference project in this workspace still follows that stack, but in slightly different ways:

## niflib-develop
- Meshes are `NiGeometry`/`NiTriShape` trees that may host a `NiSkinInstance`. That instance points to both the skinning data (`NiSkinData`) and an optional `NiSkinPartition` (hardware-friendly partitions) and keeps a direct pointer to the skeleton root plus a list of `NiNode` bones (`reference_projects/niflib-develop/include/obj/NiSkinInstance.h:1-113`). The skin data stores per-bone transforms (bind pose offsets) and the vertex-weight lists (`reference_projects/niflib-develop/include/obj/NiSkinData.h:1-169`).
- The `NiSkinPartition` object divides the mesh into small chunks so every vertex in a chunk touches at most a fixed number of bones, which helps when generating GPU-friendly vertex formats (`doc/NiSkinPartition.html:1-38`). This partitioning differs from the “max 4 bones per vertex” rule most engines assume because the Ni data may split the mesh into many strips/triangles with their own weight tables rather than forcing a global limit.
- Animation is not stored with the mesh but in controller objects that reference nodes (and therefore bones) via `NiControllerSequence`/`NiStringPalette` entries. The controller architecture (NiTimeController, NiInterpController, NiSingleInterpController) sits alongside the mesh data instead of being embedded in the geometry, which is why Ni exporters often ship `.kf` files separately from `.nif` scenes. The controller links contain the node names and controller/interpolator IDs rather than bone indices, which makes the linking more dynamic but also more tightly tied to node naming/references (`doc/NiSkinInstance.html`, `reference_projects/niflib-develop/include/obj/NiControllerSequence.h`).

## nif-main
- The Rust parser mirrors the native NIF structures. `NiSkinInstance` records references to the skin data block, the optional partition, the skeleton root block index, and each influencing bone index (`reference_projects/nif-main/src/blocks/ni_main/ni_skin_instance.rs:1-25`). Those block references are just indices into the parsed block list (`common/refs.rs`), so the skeleton graph is reconstructed by walking the NiNode hierarchy while consulting these block refs.
- `NiSkinData` includes a `NiTransform` per bone (bind transform) plus per-bone vertex weight lists (`reference_projects/nif-main/src/blocks/ni_main/ni_skin_data.rs:1-35`). The parser stores those weights exactly as they appear, so the reader can later reprovision GPU weight buffers or compute skinned vertices in software. The `NiSkinPartition` struct retains the per-partition bone list, vertex maps (for remapping indices), strip data, and optional bone index tables (`reference_projects/nif-main/src/blocks/ni_main/ni_skin_partition.rs:1-83`). That low-level representation is more granular than a typical per-vertex-BoneCount approach.
- Animation controllers are parsed through the block system as well (`reference_projects/nif-main/src/blocks/mod.rs` includes every controller/interpolator type), meaning the runtime sees the same NiTimeController / NiInterpolator triple that a `.kf` file would use. Since the parser is generic, it does not automatically apply animation; it simply gives you the raw bones, node links, and controller blocks so you can build your own animation runtime.

## NifSkope
- Skeleton and mesh display rely on the `Node`/`Controller` classes in `src/gl/`. Each `Node` wraps an `NiNode`/`NiTriShape`, keeps transform data, and accumulates attached `Controller` objects (`reference_projects/nifskope-develop/src/gl/glnode.cpp:1-195`). The Node tree is rebuilt each time a block changes—child links are walked via `Children` arrays, and `Controller` lookups filter by property type and controller type (`reference_projects/nifskope-develop/src/gl/glnode.cpp:200-320`).
- Instead of generating a new skeleton for rendering, NifSkope keeps the NiNodes as the source-of-truth and simply renders their transforms, textures, and geometry. When the `spAttachKf` spell runs it reads a `.kf` file, ensures its roots are `NiControllerSequence`, finds the “Accum Root Name”, and attaches the targeted bones to a `NiMultiTargetTransformController` / `NiControllerManager` combination inside the current `.nif` (`reference_projects/nifskope-develop/src/spells/animation.cpp:13-170`). This “attach-at-runtime” model differs from typical engines: animations live in separate files and need explicit reassignment to the mesh hierarchy, whereas most engines bake animation clips into the mesh asset or reference bone indices directly.
- Controller lookup/creation uses property palettes and name-based matching (`spAttachKf` calls `findChildNode`, `findController`, and `attachController`, while `gl/glnode.cpp` hosts the controller factory). Because Ni Controllers target nodes by name (or by string palette offsets), the spell must find the exact node names before it can register sequences. This is more brittle than per-index animation data but lets `.kf` files be reused against nodes that share the same naming convention.

## NifToOpenGL
- The project parses skeletons by walking the `.nif` block graph. `NodeGeneral`/`NodeGeometry` and `NodeController` classes read child links, controller targets, and transform data (`reference_projects/NifToOpenGL/NifNode.cs:66-200`). Each controller type (transform, alpha, visibility, etc.) inherits from `NodeController`, meaning the reader can respond to multiple controllers acting on the same node.
- Bone-weighted skinning is captured by the `Bone`, `Partition`, and `MatchGroup` helpers in `NifMain.cs`, which read rotation/translation/scale matrices for bones and per-partition vertex weight tables (`reference_projects/NifToOpenGL/NifMain.cs:95-195`). Unlike the Ni partition structures in `NiSkinPartition`, this code targets the Civ4 flavor of `.nif` and therefore already assumes the per-partition data layout rather than a global `NiSkinPartition` block.
- Animation data is expected to be embedded inside the `.nif`: there is no `.kf` loader here. The controllers referenced by `NodeController` instances are the typical NiTimeController + interpolator blocks, so the animation flow is simpler (just parse the relevant controllers and apply them). NifToOpenGL therefore differs from the `.kf`-based pipeline by keeping all transforms and weights inside the `.nif`, avoiding the need to merge separate keyframe files.

## OpenMW
- OpenMW’s NIF component defines `ControlledBlock` (target names, interpolators, controller IDs, etc.) plus the full Ni controller hierarchy in `components/nif/controller.hpp` (`reference_projects/OpenMW-Approach/openmw/components/nif/controller.hpp:11-194`). Each controlled block carries references to the interpolator/controller, the bone indices (offsets into the skeleton), and the optional `NiStringPalette` entries. That mirrors what the `.kf` spec expects: controllers list the node name, controller type, and interpolator that governs it.
- Skeletons reuse the NiNode tree; `NiControllerSequence::read()` simply parses Gamebryo’s root fields (weight, frequency, start/stop times, controller manager, and optionally a string palette) and hands them off to the `NiControllerManager` (`reference_projects/OpenMW-Approach/openmw/components/nif/controller.cpp:107-166`). The `NiStringPalette` is used to deduplicate node/controller names, which are stored centrally rather than repeated on each `ControlledBlock`. The `NiInterpController`/`NiSingleInterpController` implementations extend `NiTimeController` and read interpolators, allowing OpenMW to resolve animation curves before applying them to the skeleton (`reference_projects/OpenMW-Approach/openmw/components/nif/controller.cpp:144-166`).
- Unlike many engines that store animation clips as per-bone tracks referencing bone indices, this pipeline keeps animation metadata in more general controller structures that reference nodes by name/palette, so the actual skeleton bones are resolved by node names at runtime. That is also why OpenMW needs a `NiControllerManager`: multiple sequences can target the same controller simultaneously, and the manager arbitrates priorities, blending, and playback order. The Ni data does not assume strict per-bone keyframe arrays, so timeline control is implemented via controllers instead of the conventional clip/bone paradigm.

## Summary
- All of these projects use the NetImmerse/Gamebryo ideas of `NiSkinInstance` + `NiSkinData` + `NiSkinPartition` for skeletons, plus controllers (`NiTimeController`, `NiInterpController`, etc.) to animate nodes.
- `niflib` exposes the full object graph plus helper APIs, `nif-main` exposes the raw blocks so you can reassemble skeletons yourself, `NifSkope` keeps everything in the editor tree and attaches `.kf` sequences via spells, `NifToOpenGL` assumes the animation data lives inside `.nif`, and `OpenMW` drives the controller/palette system that Gamebryo exporters expect.
- Compared to the typical clip/bone-index approach, the Gamebryo pipeline keeps animations in controller files that match nodes by name. Mesh skeletons are built by linking `NiSkinInstance` bones to NiNodes rather than storing a simple bone-index array, and animation differences arise from the need to attach controllers through `NiControllerManager`/`ControlledBlock` structures instead of just reusing per-bone keyframe arrays.
